<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ConstTypeArgs.Core</name>
    </assembly>
    <members>
        <member name="T:ConstTypeArgs.ConstTypeArgException">
            <summary>
            The <see cref="T:ConstTypeArgs.ConstTypeArgException"/> class is used to throw exceptions when an operation is attempted
            using a const type argument and unrecoverably fails.
            </summary>
            <remarks>
            Use the <see cref="M:ConstTypeArgs.ConstTypeArgException.Throw(System.Type,System.Object,System.Boolean,System.String,System.Exception)"/> and <see cref="M:ConstTypeArgs.ConstTypeArgException.Throw``2(System.String,System.Exception)"/>
            static methods to throw this exception.
            </remarks>
        </member>
        <member name="F:ConstTypeArgs.ConstTypeArgException.DefaultDescriptionFormat">
            <summary>
            The default description format for the exception.
            </summary>
            <seealso cref="M:ConstTypeArgs.ConstTypeException.FormatDefaultMessage(System.Text.CompositeFormat,System.Object[])"/>
        </member>
        <member name="P:ConstTypeArgs.ConstTypeArgException.ArgValue">
            <summary>
            Required. Gets &amp; inits the value of the const type argument associated with this exception.
            </summary>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeArgException.#ctor">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.ConstTypeArgException"/> instance.
            </summary>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeArgException.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.ConstTypeArgException"/> instance with the specified error message.
            </summary>
            <param name="message">
            The message explaining the cause of the exception.
            </param>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeArgException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.ConstTypeArgException"/> instance with the specified error message
            and a reference to the inner exception that caused this one to be thrown.
            </summary>
            <param name="message">
            The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception.
            </param>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeArgException.Throw(System.Type,System.Object,System.Boolean,System.String,System.Exception)">
            <summary>
            Throws a new <see cref="T:ConstTypeArgs.ConstTypeArgException"/> with the specified parameters.
            </summary>
            <param name="type">
            The const type arg causing the exception to be thrown.
            </param>
            <param name="value">
            Optional. The const type argument's value.
            </param>
            <param name="isUndefined">
            Optional. Indicates that the const type argument has no value. This value is only used if <paramref name="value"/>
            is not provided or is <see langword="null"/>. If so, the displayed value is <c>UNDEFINED</c>.
            The default is <see langword="false"/>.
            </param>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            Optional. The exception that is the cause of the current exception.
            </param>
            <exception cref="T:ConstTypeArgs.ConstTypeArgException"/>
            <seealso cref="M:ConstTypeArgs.ConstTypeArgException.Throw``2(System.String,System.Exception)"/>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeArgException.Throw``2(System.String,System.Exception)">
            <summary>
            Throws an exception for a const type argument <typeparamref name="K"/> with the specified parameters.
            </summary>
            <typeparam name="T">
            The type of the value of the const type argument associated with the exception.
            </typeparam>
            <typeparam name="K">
            The const type argument associated with the exception.
            </typeparam>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            Optional. The exception that is the cause of the current exception.
            </param>
            <remarks>
            If the const type argument <typeparamref name="K"/> has no value, the displayed value is <c>UNDEFINED</c>.
            </remarks>
            <exception cref="T:ConstTypeArgs.ConstTypeArgException"/>
            <seealso cref="M:ConstTypeArgs.ConstTypeArgException.Throw(System.Type,System.Object,System.Boolean,System.String,System.Exception)"/>
        </member>
        <member name="T:ConstTypeArgs.ConstTypeException">
            <summary>
            The <see cref="T:ConstTypeArgs.ConstTypeException"/> class is the basic framework exception for exceptions
            related to errors involving const types <em>(const type arguments, const type interfaces,
            argument providers, etc.)</em>.
            </summary>
            <remarks>
            Use the <see cref="M:ConstTypeArgs.ConstTypeException.Throw(System.Type,System.String,System.Exception)"/> and <see cref="M:ConstTypeArgs.ConstTypeException.Throw``1(System.String,System.Exception)"/>
            static methods to throw this exception.
            </remarks>
        </member>
        <member name="F:ConstTypeArgs.ConstTypeException.DefaultDescriptionFormat">
            <summary>
            The default description format for the exception.
            </summary>
            <seealso cref="M:ConstTypeArgs.ConstTypeException.FormatDefaultMessage(System.Text.CompositeFormat,System.Object[])"/>
        </member>
        <member name="P:ConstTypeArgs.ConstTypeException.Type">
            <summary>
            Required. Gets &amp; inits the const type that was the cause of the exception being thrown.
            </summary>
        </member>
        <member name="P:ConstTypeArgs.ConstTypeException.TypeName">
            <summary>
            Gets the name of the const type that was the cause of the exception being thrown.
            </summary>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeException.#ctor">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.ConstTypeException"/> instance.
            </summary>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeException.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.ConstTypeException"/> instance with the specified error message.
            </summary>
            <param name="message">
            The message explaining the cause of the exception.
            </param>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.ConstTypeException"/> instance with the specified error message
            and a reference to the inner exception that caused this one to be thrown.
            </summary>
            <param name="message">
            The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception.
            </param>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeException.Throw(System.Type,System.String,System.Exception)">
            <summary>
            Throws a new <see cref="T:ConstTypeArgs.ConstTypeException"/> with the specified parameters.
            </summary>
            <param name="type">
            The type causing the exception to be thrown.
            </param>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            Optional. The exception that is the cause of the current exception.
            </param>
            <exception cref="T:ConstTypeArgs.ConstTypeException"/>
            <seealso cref="M:ConstTypeArgs.ConstTypeException.Throw``1(System.String,System.Exception)"/>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeException.Throw``1(System.String,System.Exception)">
            <summary>
            Throws a new <see cref="T:ConstTypeArgs.ConstTypeException"/> with the specified parameters.
            </summary>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            Optional. The exception that is the cause of the current exception.
            </param>
            <typeparam name="T">
            The const type causing the exception to be thrown.
            </typeparam>
            <exception cref="T:ConstTypeArgs.ConstTypeException"/>
            <seealso cref="M:ConstTypeArgs.ConstTypeException.Throw(System.Type,System.String,System.Exception)"/>
        </member>
        <member name="M:ConstTypeArgs.ConstTypeException.FormatDefaultMessage(System.Text.CompositeFormat,System.Object[])">
            <summary>
            Returns a formatted message for the exception with the specified format and arguments.
            </summary>
            <param name="format">
            The format to use for the message.
            </param>
            <param name="args">
            The arguments to use for the message.
            </param>
            <returns>
            A formatted message for the exception.
            </returns>
            <remarks>
            The message is formatted using the
            <see href="https://learn.microsoft.com/dotnet/api/system.globalization.cultureinfo.invariantculture">
            System.Globalization.CultureInfo.InvariantCulture</see>
            to ensure that the message is formatted correctly. See the article
            <see href="https://learn.microsoft.com/dotnet/fundamentals/runtime-libraries/system-globalization-cultureinfo-invariantculture">
            System.Globalization.CultureInfo.InvariantCulture property</see> for more information about the invariant
            culture.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown <paramref name="args"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.FormatException">
            Thrown <paramref name="args"/> has a length greater than or less than
            <see href="https://learn.microsoft.com/dotnet/api/system.text.compositeformat.minimumargumentcount">
            composite.MinimumArgumentCount</see>.
            </exception>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Array">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Array"/> interface provides a base interface for identifying
            const type argument arrays.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Array`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Array`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values to
            types of arrays.
            </summary>
            <typeparam name="T">
            The type of array of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_Class`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Integer`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Class">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Class"/> interface provides a base interface for identifying
            const type arguments whose value is a type of class.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Class`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Class`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values to
            types of classes.
            </summary>
            <typeparam name="T">
            The <see langword="class"/> of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Integer`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Delegate">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Delegate"/> interface provides a base interface for identifying
            const type argument delegates
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Delegate`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Delegate`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to <see langword="delegate"/> types.
            </summary>
            <typeparam name="T">
            The <see langword="delegate"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Class`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Enum">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Enum"/> interface provides a base interface for identifying
            const type argument with values that are a type of enum.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Enum`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Enum`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to <see langword="enum"/> types.
            </summary>
            <typeparam name="T">
            The <see langword="enum"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_Class`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_FloatingPoint">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_FloatingPoint"/> interface provides a base interface for identifying
            const type argument floating point values.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_FloatingPoint`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.ifloatingpoint-1">
            K_FloatingPoint&lt;T&gt;</see>
            types.
            </summary>
            <typeparam name="T">
            The <see cref="T:System.Numerics.IFloatingPoint`1"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_Integer`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Integer">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Integer"/> interface provides a base interface for identifying
            const type argument whose values are a type of
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.ibinaryinteger-1">
            IBinaryInteger&lt;T&gt;</see>.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Integer`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Integer`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.ibinaryinteger-1">
            IBinaryInteger&lt;T&gt;</see>
            types.
            </summary>
            <typeparam name="T">
            The <see cref="T:System.Numerics.IBinaryInteger`1"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_MulticastDelegate">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_MulticastDelegate"/> interface provides a base interface for identifying
            const type argument that are multicast delegates.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_MulticastDelegate`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to <see langword="delegate"/> types of type
            <see href="https://learn.microsoft.com/dotnet/api/system.multicastdelegate">
            MulticastDelegate</see>.
            </summary>
            <typeparam name="T">
            The <see langword="delegate"/> type of the const type argument's value.
            </typeparam>
            <remarks>
            Implement this for const type arguments when delegate chaining is desired.
            </remarks>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Class`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Number">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Number"/> interface provides a base interface for identifying
            const type argument with values that are a type of
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.inumber-1">
            INumber&lt;T&gt;</see>.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Number`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Number`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.inumber-1">
            INumber&lt;T&gt;</see>
            types.
            </summary>
            <typeparam name="T">
            The <see cref="T:System.Numerics.INumber`1"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_ReadOnlyMemory">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_ReadOnlyMemory"/> interface provides a base interface for identifying
            const type argument with values that are a type of
            <see href="https://learn.microsoft.com/dotnet/api/system.readonlymemory-1">
            ReadOnlyMemory&lt;T&gt;</see>.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_ReadOnlyMemory`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_ReadOnlyMemory`1"/> interface provides a more explicit
            <see cref="T:ConstTypeArgs.IConstTypeArg`1">IConstTypeArg&lt;ReadOnlyMemory&lt;T&gt;&gt;</see> derived type.
            </summary>
            <typeparam name="T">
            The type of items held in memory.
            </typeparam>
            <seealso href="https://learn.microsoft.com/dotnet/api/system.readonlymemory-1">ReadOnlyMemory&lt;T&gt;</seealso>
            <seealso cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryArray`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryT_Array`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_ReadOnlyMemory`1.__">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_ReadOnlyMemory`1.__"/> interface is a <em>discard argument</em> meant to signify
            a lack of value and is used as a placeholder in type parameter lists.
            When combined with other discard arguments of other types, it can be used to create
            union-like behavior.
            </summary>
        </member>
        <member name="T:ConstTypeArgs.Core.K_ReadOnlyMemoryArray`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryArray`1"/> interface provides a more explicit
            <see cref="T:ConstTypeArgs.IConstTypeArg`1">IConstTypeArg&lt;ReadOnlyMemory&lt;T&gt;[]&gt;</see> derived type.
            </summary>
            <typeparam name="T">
            The type of items held in memory.
            </typeparam>
            <remarks>
            This type is used to provide arrays of <c>ReadOnlyMemory</c>, as opposed to an array inside <c>ReadOnlyMemory</c>.
            See <see cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryT_Array`1"/> for more information.
            </remarks>
            <seealso href="https://learn.microsoft.com/dotnet/api/system.readonlymemory-1">ReadOnlyMemory&lt;T&gt;</seealso>
            <seealso cref="T:ConstTypeArgs.Core.K_ReadOnlyMemory`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryT_Array`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_ReadOnlyMemoryArray`1.__">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryArray`1.__"/> interface is a <em>discard argument</em> meant to signify
            a lack of value and is used as a placeholder in type parameter lists.
            When combined with other discard arguments of other types, it can be used to create
            union-like behavior.
            </summary>
        </member>
        <member name="T:ConstTypeArgs.Core.K_ReadOnlyMemoryT_Array`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryT_Array`1"/> interface provides a more explicit
            <see cref="T:ConstTypeArgs.IConstTypeArg`1">IConstTypeArg&lt;ReadOnlyMemory&lt;T[]&gt;&gt;</see> derived type.
            </summary>
            <typeparam name="T">
            The type of items held in memory.
            </typeparam>
            <remarks>
            This type is used to provide an array inside <c>ReadOnlyMemory</c>, as opposed to arrays of <c>ReadOnlyMemory</c>.
            See <see cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryArray`1"/> for more information.
            </remarks>
            <seealso href="https://learn.microsoft.com/dotnet/api/system.readonlymemory-1">ReadOnlyMemory&lt;T&gt;</seealso>
            <seealso cref="T:ConstTypeArgs.Core.K_ReadOnlyMemory`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_ReadOnlyMemoryArray`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_SignedNumber">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_SignedNumber"/> interface provides a base interface for identifying
            const type argument with values that implement
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.isignednumber-1">
            ISignedNumber&lt;T&gt;</see>.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_SignedNumber`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/> interface provides a base type
            for all interfaces used to constrain generic const type argument values
            to
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.isignednumber-1">
            ISignedNumber&lt;T&gt;</see>
            types.
            </summary>
            <typeparam name="T">
            The <see cref="T:System.Numerics.ISignedNumber`1"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Integer`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Struct">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Struct"/> interface provides a base interface for identifying
            const type argument with values that are a type of struct.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Struct`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Struct`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to <see langword="struct"/> types.
            </summary>
            <typeparam name="T">
            The <see langword="struct"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_Class`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Integer`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Unmanaged">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Unmanaged"/> interface provides a base interface for identifying
            const type argument with values that are an unmanaged type.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_Unmanaged`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to <see langword="unmanaged"/> types.
            </summary>
            <typeparam name="T">
            The <see langword="unmanaged"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_Class`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Integer`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.K_UnsignedNumber">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_UnsignedNumber"/> interface provides a base interface for identifying
            const type argument with values that implement
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.iunsignednumber-1">
            ISignedNumber&lt;T&gt;</see>.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.Core.K_UnsignedNumber`1">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.K_UnsignedNumber`1"/> interface provides a base type
            for all interfaces used to constrain const type argument values
            to
            <see href="https://learn.microsoft.com/dotnet/api/system.numerics.iunsignednumber-1">
            IUnsignedNumber&lt;T&gt;</see>
            types.
            </summary>
            <typeparam name="T">
            The <see cref="T:System.Numerics.IUnsignedNumber`1"/> type of the const type argument's value.
            </typeparam>
            <seealso cref="T:ConstTypeArgs.Core.K_FloatingPoint`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Integer`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Number`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_SignedNumber`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Array`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Delegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_MulticastDelegate`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Enum`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Struct`1"/>
            <seealso cref="T:ConstTypeArgs.Core.K_Unmanaged`1"/>
        </member>
        <member name="T:ConstTypeArgs.Core.__">
            <summary>
            The <see cref="T:ConstTypeArgs.Core.__"/> interface is a special type of marker interface
            meant to identify const type args that are used as discards in type parameter
            list with union-like behavior.
            </summary>
        </member>
        <member name="T:ConstTypeArgs.IConstTypeArg">
            <summary>
            The <see cref="T:ConstTypeArgs.IConstTypeArg"/> interface provides a base interface for identifying
            const type argument providers, which are used to pass static read-only &amp; constant
            values to generic types, delegates, &amp; methods.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.IConstTypeArg`1">
            <summary>
            The <see cref="T:ConstTypeArgs.IConstTypeArg`1"/> interface uses static abstract interface methods
            to provide the means to "pass" values to generic types, delegates, and methods. These
            values are then directly accessible from within a static context, such as type initializers
            and static methods &amp; fields. This mimics the behavior of C++'s template specialization (go to
            <a href="https://en.cppreference.com/w/cpp/language/template_specialization">
            Template Specialization</a> for more information).
            </summary>
            <typeparam name="T">
            The type of the values to be passed as const type arguments.
            </typeparam>
            <remarks>
            This is intended to provide access to values that are, but not limited to,
            static readonly values. <strong><em>IMMUTABILITY IS HOWEVER STRONGLY RECOMMENDED.</em></strong>
              <note type="important">
              Because <see cref="T:ConstTypeArgs.IConstTypeArg`1"/> type definitions are <em>argument providers</em>,
              they are intended to be used as type parameters or as a means to access readonly static values
              <em>(recommended)</em> or constants. There are few reasons to instantiate them, pass them as
              arguments to a method, or use them as a return type. There is a very low risk of their usage
              causing unintended side-effects without a deliberate misuse of reflection.
              <para>
              For more information, see the developer documentation.
              </para>
              </note>
            </remarks>
        </member>
        <member name="P:ConstTypeArgs.IConstTypeArg`1.Value">
            <summary>
            Gets a const type argument's value.
            </summary>
            <value>
            The const type argument's value.
            </value>
            <seealso cref="M:ConstTypeArgs.IConstTypeArg`2.GetValue"/>
        </member>
        <member name="T:ConstTypeArgs.IConstTypeArg`2">
            <summary>
            The <see cref="T:ConstTypeArgs.IConstTypeArg`2"/> interface is used to complement
            <em>argument providers</em> where, in certain cases, it may not be possible to determine
            an argument provider's type at compile-time
            </summary>
            <typeparam name="T">
            The type of values to be passed as const type arguments.
            </typeparam>
            <typeparam name="TSelf">
            The implementing type itself.
            </typeparam>
            <remarks>
            In rare use cases, an argument provider's type might need to be known but cannot be determined
            at runtime. In such situations, <see cref="T:ConstTypeArgs.IConstTypeArg`2"/> can prove helpful,
            though types implementing this interface are still const type arguments and generally should
            not be instantiated, passed as arguments to a method, or used as a return type.
            This maintains a very low risk of their usage causing unintended side-effects
            without a deliberate misuse of reflection.
            </remarks>
        </member>
        <member name="M:ConstTypeArgs.IConstTypeArg`2.GetValue">
            <summary>
            Returns a const type argument's value.
            </summary>
            <returns>
            The const type argument's value.
            </returns>
            <seealso cref="P:ConstTypeArgs.IConstTypeArg`1.Value"/>
        </member>
        <member name="T:ConstTypeArgs.K">
            <summary>
            The <see cref="T:ConstTypeArgs.K"/> interface provides a base interface for identifying
            const type argument holders, which are types of const type argument providers
            that wrap <em>(i.e. hold)</em> the values of other const type argument providers.
            </summary>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.K`1">
            <summary>
            The <see cref="T:ConstTypeArgs.K`1"/> interface provides a base interface for identifying
            const type argument holders, which are types of const type argument providers
            that wrap <em>(i.e. hold)</em> the values of other const type argument providers.
            </summary>
            <typeparam name="TArg">
            The const type argument provider containing the value to be held.
            </typeparam>
            <remarks>
            This is a marker interface intended for very limited usage. It can be useful to simplify
            type testing &amp; type parameter constraints.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.K`2">
            <summary>
            The <see cref="T:ConstTypeArgs.K`2"/> interface provides the means to implement an argument provider
            that wraps the value from another argument provider specified in <typeparamref name="TArg"/>.
            </summary>
            <typeparam name="T">
            The wrapped value's type.
            </typeparam>
            <typeparam name="TArg">
            The argument provider containing the value to be wrapped.
            </typeparam>
            <remarks>
            Use <see cref="T:ConstTypeArgs.K`2"/> to reuse values from other argument providers to provide
            domain-specific constants, such as minimum, maximum, &amp; default values.
            </remarks>
        </member>
        <member name="T:ConstTypeArgs.MisleadingConstTypeException">
            <summary>
            The <see cref="T:ConstTypeArgs.MisleadingConstTypeException"/> class provides an exception that is thrown when an operation is attempted
            on a type that indicates it is a const type that it is not, causing an unrecoverable failure.
            </summary>
            <remarks>
            Use the <see cref="M:ConstTypeArgs.MisleadingConstTypeException.Throw``3(System.String,System.Exception)"/>
            and <see cref="M:ConstTypeArgs.MisleadingConstTypeException.ThrowIfMisleading``3(System.String)"/> static methods to throw this exception.
              <para>
              Many const types derive from marker interfaces, such as <see cref="T:ConstTypeArgs.IConstTypeArg"/> and <see cref="T:ConstTypeArgs.K"/>,
              that occasionally have use in activities such as type testing. However, types implementing the marker interfaces
              do not have to implement the const type itself <em>(e.g. the type implements <see cref="T:ConstTypeArgs.IConstTypeArg"/> but
              not <see cref="T:ConstTypeArgs.IConstTypeArg`1"/>)</em>. In such cases where this can cause a failure that cannot be recovered from,
              throw this exception.
              </para>
            </remarks>
        </member>
        <member name="F:ConstTypeArgs.MisleadingConstTypeException.DefaultDescriptionFormat">
            <summary>
            The default description format for the exception.
            </summary>
            <seealso cref="M:ConstTypeArgs.ConstTypeException.FormatDefaultMessage(System.Text.CompositeFormat,System.Object[])"/>
        </member>
        <member name="P:ConstTypeArgs.MisleadingConstTypeException.TypeMarked">
            <summary>
            Gets &amp; inits the type the const type <see cref="P:ConstTypeArgs.ConstTypeException.Type"/> is misleadingly marked as.
            </summary>
            <seealso cref="P:ConstTypeArgs.MisleadingConstTypeException.TypeNotImplemented"/>
        </member>
        <member name="P:ConstTypeArgs.MisleadingConstTypeException.TypeNotImplemented">
            <summary>
            Gets &amp; inits the type the const type <see cref="P:ConstTypeArgs.ConstTypeException.Type"/> is
            misleadingly marked as implementing.
            </summary>
            <seealso cref="P:ConstTypeArgs.MisleadingConstTypeException.TypeMarked"/>
        </member>
        <member name="M:ConstTypeArgs.MisleadingConstTypeException.#ctor">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.MisleadingConstTypeException"/> instance.
            </summary>
        </member>
        <member name="M:ConstTypeArgs.MisleadingConstTypeException.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.MisleadingConstTypeException"/> instance with the specified error message.
            </summary>
            <param name="message">
            The message explaining the cause of the exception.
            </param>
        </member>
        <member name="M:ConstTypeArgs.MisleadingConstTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.MisleadingConstTypeException"/> instance with the specified error message
            and a reference to the inner exception that caused this one to be thrown.
            </summary>
            <param name="message">
            The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception.
            </param>
        </member>
        <member name="M:ConstTypeArgs.MisleadingConstTypeException.Throw``3(System.String,System.Exception)">
            <summary>
            Throws <see cref="T:ConstTypeArgs.MisleadingConstTypeException"/> to indicate that the const type <typeparamref name="K"/>
            is marked as <typeparamref name="K_Marked"/> but does not implement <typeparamref name="K_Not"/> as expected.
            </summary>
            <typeparam name="K">
            The const type that is the cause of the exception.
            </typeparam>
            <typeparam name="K_Marked">
            A marker interface that <see cref="T:ConstTypeArgs.K"/> implements.
            </typeparam>
            <typeparam name="K_Not">
            A const type that implements <typeparamref name="K_Marked"/>.
            </typeparam>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            Optional. The exception that is the cause of the current exception.
            </param>
            <remarks>
            This method does not and is not intended to check if <typeparamref name="K"/> implements <typeparamref name="K_Not"/>.
            </remarks>
            <exception cref="T:ConstTypeArgs.MisleadingConstTypeException"/>
        </member>
        <member name="M:ConstTypeArgs.MisleadingConstTypeException.ThrowIfMisleading``3(System.String)">
            <summary>
            Throws <see cref="T:ConstTypeArgs.MisleadingConstTypeException"/> if the const type <typeparamref name="K"/> is marked as
            <typeparamref name="K_Marked"/> but does not implement <typeparamref name="K_Check"/> as expected.
            </summary>
            <typeparam name="K">
            The const type to check.
            </typeparam>
            <typeparam name="K_Marked">
            The type <typeparamref name="K"/> is marked as.
            </typeparam>
            <typeparam name="K_Check">
            The type to check whether or not <typeparamref name="K"/> implements.
            </typeparam>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
        </member>
        <member name="T:ConstTypeArgs.UndefinedConstTypeArgException">
            <summary>
            The <see cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/> class is thrown when an operation is expecting
            a const type argument to have a value, but the value is undefined, causing an unrecoverable failure.
            </summary>
            <remarks>
            Use the <see cref="M:ConstTypeArgs.UndefinedConstTypeArgException.Throw(System.Type,System.String,System.Exception)"/>, <see cref="M:ConstTypeArgs.UndefinedConstTypeArgException.Throw``1(System.String,System.Exception)"/>,
            and <see cref="M:ConstTypeArgs.UndefinedConstTypeArgException.ThrowIfNoValue``2(System.String)"/> static methods to throw this exception.
            </remarks>
        </member>
        <member name="F:ConstTypeArgs.UndefinedConstTypeArgException.DefaultDescriptionFormat">
            <summary>
            The default description format for the exception.
            </summary>
            <seealso cref="M:ConstTypeArgs.ConstTypeException.FormatDefaultMessage(System.Text.CompositeFormat,System.Object[])"/>
        </member>
        <member name="M:ConstTypeArgs.UndefinedConstTypeArgException.#ctor">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/> instance.
            </summary>
        </member>
        <member name="M:ConstTypeArgs.UndefinedConstTypeArgException.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/> instance with the specified error message.
            </summary>
            <param name="message">
            The message explaining the cause of the exception.
            </param>
        </member>
        <member name="M:ConstTypeArgs.UndefinedConstTypeArgException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new <see cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/> instance with the specified error message
            and a reference to the inner exception that caused this one to be thrown.
            </summary>
            <param name="message">
            The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception.
            </param>
        </member>
        <member name="M:ConstTypeArgs.UndefinedConstTypeArgException.Throw(System.Type,System.String,System.Exception)">
            <summary>
            Throws a new <see cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/> with the specified parameters.
            </summary>
            <param name="type">
            The type causing the exception to be thrown.
            </param>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            Optional. The exception that is the cause of the current exception.
            </param>
            <remarks>
            This method does not and is not intended to check if <paramref name="type"/> is a const type itself.
            </remarks>
            <exception cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/>
            <seealso cref="M:ConstTypeArgs.UndefinedConstTypeArgException.Throw``1(System.String,System.Exception)"/>
            <seealso cref="M:ConstTypeArgs.UndefinedConstTypeArgException.ThrowIfNoValue``2(System.String)"/>
        </member>
        <member name="M:ConstTypeArgs.UndefinedConstTypeArgException.Throw``1(System.String,System.Exception)">
            <summary>
            Throws a new <see cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/> with the specified parameters.
            </summary>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
            <param name="innerException">
            Optional. The exception that is the cause of the current exception.
            </param>
            <typeparam name="K">
            The const type causing the exception to be thrown.
            </typeparam>
            <exception cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/>
            <seealso cref="M:ConstTypeArgs.UndefinedConstTypeArgException.Throw(System.Type,System.String,System.Exception)"/>
            <seealso cref="M:ConstTypeArgs.UndefinedConstTypeArgException.ThrowIfNoValue``2(System.String)"/>
        </member>
        <member name="M:ConstTypeArgs.UndefinedConstTypeArgException.ThrowIfNoValue``2(System.String)">
            <summary>
            Throws a new <see cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/> with the specified message if either
            the const type argument <typeparamref name="K"/> has no value or <typeparamref name="K"/>
            is a type of <em>discard</em> const type argument <em>(i.e. a const type argument implementing
            <see cref="T:ConstTypeArgs.Core.__"/> to indicate it has no value)</em>.
            </summary>
            <typeparam name="T">
            The type of the value of the const type argument <typeparamref name="K"/>.
            </typeparam>
            <typeparam name="K">
            The const type argument.
            </typeparam>
            <param name="message">
            Optional. The message explaining the cause of the exception.
            </param>
            <exception cref="T:ConstTypeArgs.UndefinedConstTypeArgException"/>
            <seealso cref="M:ConstTypeArgs.UndefinedConstTypeArgException.Throw(System.Type,System.String,System.Exception)"/>
            <seealso cref="M:ConstTypeArgs.UndefinedConstTypeArgException.Throw``1(System.String,System.Exception)"/>
        </member>
        <member name="T:ConstTypeArgs.__">
            <summary>
            The <see cref="T:ConstTypeArgs.__"/> interface is a special type of marker interface
            meant to identify const type args that are used as discards in type parameter
            list with union-like behavior.
            </summary>
        </member>
    </members>
</doc>
